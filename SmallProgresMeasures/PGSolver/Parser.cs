// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace PGSolver {
	#region Parser

	public partial class Parser {
		private Scanner scanner;
		private ParseTree tree;

		public Parser(Scanner scanner) {
			this.scanner = scanner;
		}

		public ParseTree Parse(string input) {
			tree = new ParseTree();
			return Parse(input, tree);
		}

		public ParseTree Parse(string input, ParseTree tree) {
			scanner.Init(input);

			this.tree = tree;
			ParseStart(tree);
			tree.Skipped = scanner.Skipped;

			return tree;
		}

		private void ParseStart(ParseNode parent) {
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
			parent.Nodes.Add(node);



			ParseParityGame(node);


			tok = scanner.Scan(TokenType.EOF);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.EOF) {
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseParityGame(ParseNode parent) {
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParityGame), "ParityGame");
			parent.Nodes.Add(node);



			tok = scanner.LookAhead(TokenType.PARITY);
			if (tok.Type == TokenType.PARITY) {


				tok = scanner.Scan(TokenType.PARITY);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.PARITY) {
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARITY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
					return;
				}


				tok = scanner.Scan(TokenType.IDENTIFIER);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.IDENTIFIER) {
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
					return;
				}


				tok = scanner.Scan(TokenType.SEMICOLON);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.SEMICOLON) {
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
					return;
				}
			}


			do {
				ParseNodeSpec(node);
				tok = scanner.LookAhead(TokenType.IDENTIFIER);
			} while (tok.Type == TokenType.IDENTIFIER);

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseNodeSpec(ParseNode parent) {
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NodeSpec), "NodeSpec");
			parent.Nodes.Add(node);



			tok = scanner.Scan(TokenType.IDENTIFIER);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER) {
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
				return;
			}


			tok = scanner.Scan(TokenType.IDENTIFIER);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER) {
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
				return;
			}


			tok = scanner.Scan(TokenType.IDENTIFIER);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER) {
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
				return;
			}


			ParseSuccessors(node);


			tok = scanner.LookAhead(TokenType.STRING);
			if (tok.Type == TokenType.STRING) {
				tok = scanner.Scan(TokenType.STRING);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.STRING) {
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
					return;
				}
			}


			tok = scanner.Scan(TokenType.SEMICOLON);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.SEMICOLON) {
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseSuccessors(ParseNode parent) {
			Token tok;
			ParseNode n;
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Successors), "Successors");
			parent.Nodes.Add(node);



			tok = scanner.Scan(TokenType.IDENTIFIER);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER) {
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
				return;
			}


			tok = scanner.LookAhead(TokenType.COMMA);
			while (tok.Type == TokenType.COMMA) {


				tok = scanner.Scan(TokenType.COMMA);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.COMMA) {
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
					return;
				}


				tok = scanner.Scan(TokenType.IDENTIFIER);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.IDENTIFIER) {
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
					return;
				}
				tok = scanner.LookAhead(TokenType.COMMA);
			}

			parent.Token.UpdateRange(node.Token);
		}


	}

	#endregion Parser
}
